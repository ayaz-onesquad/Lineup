---
phase: 04-core-workflow-audit
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/shared/CreateModal.tsx
  - src/components/forms/SetForm.tsx
  - src/components/forms/RequirementForm.tsx
  - src/components/forms/PitchForm.tsx
autonomous: true

must_haves:
  truths:
    - "Creating Set from ClientDetailPage auto-populates client_id"
    - "Creating Set from ProjectDetailPage auto-populates project_id and derives client_id"
    - "Creating Requirement from SetDetailPage auto-populates set_id"
    - "Creating Requirement from ClientDetailPage auto-populates client_id"
    - "Cascading filters reset child fields when parent changes"
  artifacts:
    - path: "src/components/shared/CreateModal.tsx"
      provides: "Modal that passes context to all forms"
      contains: "createModalContext"
    - path: "src/components/forms/SetForm.tsx"
      provides: "Set form with cascading filters"
      contains: "useWatch"
    - path: "src/components/forms/RequirementForm.tsx"
      provides: "Requirement form with 3-level cascade"
      contains: "filteredSets"
  key_links:
    - from: "src/pages/clients/ClientDetailPage.tsx"
      to: "src/components/shared/CreateModal.tsx"
      via: "openCreateModal('set', { client_id: safeClientId })"
      pattern: "openCreateModal.*client_id"
    - from: "src/components/shared/CreateModal.tsx"
      to: "src/components/forms/SetForm.tsx"
      via: "defaultValues={createModalContext}"
      pattern: "defaultValues=.createModalContext"
---

<objective>
Verify and fix cascading filters and parent ID pre-population in forms.

Purpose: Success criteria #3 requires cascading filters (Client -> Project -> Set). Success criteria #4 requires "Create New" buttons to auto-populate parent record ID.

Output: All forms correctly receive and use parent context from CreateModal. Cascading filters properly reset child fields when parent changes.
</objective>

<execution_context>
@/Users/ayazmohammed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ayazmohammed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-workflow-audit/04-RESEARCH.md

Existing patterns:
- SetForm already has Client -> Project cascade
- RequirementForm already has Client -> Project -> Set cascade
- CreateModal passes createModalContext to most forms

Pre-population flow:
1. Detail page calls `openCreateModal('entity', { parent_id: 'xxx' })`
2. uiStore stores context in `createModalContext`
3. CreateModal passes context to form via `defaultValues={createModalContext}`
4. Form uses defaultValues in useForm initialization
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify CreateModal passes context to all forms</name>
  <files>src/components/shared/CreateModal.tsx</files>
  <action>
Verify that ALL form components receive defaultValues from createModalContext.

**Current state (from earlier read):**
- LeadForm: YES - `defaultValues={createModalContext}`
- ClientForm: NO - no defaultValues passed (OK - clients have no parent)
- ContactForm: YES - `defaultValues={createModalContext}`
- ProjectForm: YES - `defaultValues={createModalContext}`
- PhaseForm: NO - no defaultValues (placeholder form - OK to skip)
- SetForm: YES - `defaultValues={createModalContext}`
- PitchForm: YES - `defaultValues={createModalContext}`
- RequirementForm: YES - `defaultValues={createModalContext}`

No changes needed if all parent-child forms already receive defaultValues.
  </action>
  <verify>
Read CreateModal.tsx and confirm all forms that need parent context receive `defaultValues={createModalContext}`.
  </verify>
  <done>CreateModal passes createModalContext to all forms that need parent ID pre-population.</done>
</task>

<task type="auto">
  <name>Task 2: Verify cascading filter reset behavior in SetForm</name>
  <files>src/components/forms/SetForm.tsx</files>
  <action>
Verify SetForm has proper cascading behavior:

1. **Watch client_id for changes:**
   ```typescript
   const selectedClientId = useWatch({ control: form.control, name: 'client_id' })
   ```

2. **Filter projects by selected client:**
   ```typescript
   const filteredProjects = useMemo(() => {
     if (!allProjects) return []
     if (!selectedClientId) return allProjects
     return allProjects.filter((p) => p.client_id === selectedClientId)
   }, [allProjects, selectedClientId])
   ```

3. **Reset project when client changes if invalid:**
   ```typescript
   useEffect(() => {
     if (selectedClientId) {
       const currentProject = form.getValues('project_id')
       if (currentProject) {
         const projectStillValid = filteredProjects.some((p) => p.id === currentProject)
         if (!projectStillValid) {
           form.setValue('project_id', '')
         }
       }
     }
   }, [selectedClientId, filteredProjects, form])
   ```

4. **Derive client from project when project_id is passed in defaultValues:**
   Verify the existing useEffect that sets client_id from project.client_id works.

If any of these patterns are missing, add them.
  </action>
  <verify>
1. Run dev server
2. Open CreateModal, select Set tab
3. Select a client, then a project from that client
4. Change to a different client
5. Project should reset to empty (not show stale project from previous client)
  </verify>
  <done>SetForm cascading filters properly reset project when client changes.</done>
</task>

<task type="auto">
  <name>Task 3: Verify 3-level cascade in RequirementForm</name>
  <files>src/components/forms/RequirementForm.tsx</files>
  <action>
Verify RequirementForm has proper 3-level cascade (Client -> Project -> Set):

1. **Watch both parent fields:**
   ```typescript
   const selectedClientId = useWatch({ control: form.control, name: 'client_id' })
   const selectedProjectId = useWatch({ control: form.control, name: 'project_id' })
   ```

2. **Filter projects by client:**
   ```typescript
   const filteredProjects = useMemo(() => {
     if (!allProjects) return []
     if (!selectedClientId) return allProjects
     return allProjects.filter((p) => p.client_id === selectedClientId)
   }, [allProjects, selectedClientId])
   ```

3. **Filter sets by project (or client if no project):**
   Verify the existing logic handles both scenarios.

4. **Reset dependent fields in useEffect:**
   When client changes, reset project if invalid.
   When project changes, reset set if invalid.

5. **Derive parent IDs from set when set_id is passed:**
   If `defaultValues.set_id` is provided, derive client_id and project_id from the set.

Verify these patterns exist or add if missing.
  </action>
  <verify>
1. Run dev server
2. From SetDetailPage, click "Add Requirement"
3. Verify set_id is pre-populated and correct client/project are auto-selected
4. Test cascade: change client -> project should reset -> set should reset
  </verify>
  <done>RequirementForm 3-level cascade (Client -> Project -> Set) works correctly with proper reset behavior.</done>
</task>

</tasks>

<verification>
1. `npm run build` passes without TypeScript errors
2. From ClientDetailPage "Create Set" -> client_id is pre-populated
3. From ProjectDetailPage "Create Set" -> project_id pre-populated, client_id derived
4. From SetDetailPage "Add Requirement" -> set_id pre-populated, project_id and client_id derived
5. In SetForm: changing client resets project dropdown
6. In RequirementForm: changing client resets project AND set dropdowns
</verification>

<success_criteria>
- "Create New" buttons in child tabs auto-populate parent record ID
- Cascading filters work: Client filters Projects, Project filters Sets
- Child fields reset when parent changes to prevent invalid combinations
- Build completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-workflow-audit/04-03-SUMMARY.md`
</output>
