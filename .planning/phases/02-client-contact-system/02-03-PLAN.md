---
phase: 02-client-contact-system
plan: 03
type: execute
wave: 2
depends_on: ["02-02"]
files_modified:
  - src/hooks/useClients.ts
  - src/components/forms/ClientForm.tsx
autonomous: true

must_haves:
  truths:
    - "useCreateClientWithContact hook exists and calls atomic save"
    - "ClientForm includes Primary Contact section with first_name, last_name, email, phone, role"
    - "Submitting ClientForm creates client AND primary contact in one operation"
    - "Form validation requires primary contact first_name and last_name"
  artifacts:
    - path: "src/hooks/useClients.ts"
      provides: "Hook for atomic client+contact creation"
      contains: "useCreateClientWithContact"
    - path: "src/components/forms/ClientForm.tsx"
      provides: "Client form with primary contact fields"
      contains: "first_name"
  key_links:
    - from: "src/hooks/useClients.ts"
      to: "clientsApi.createWithContact"
      via: "useMutation"
      pattern: "clientsApi\\.createWithContact"
    - from: "src/components/forms/ClientForm.tsx"
      to: "useCreateClientWithContact"
      via: "hook import and call"
      pattern: "useCreateClientWithContact"
---

<objective>
Refactor client creation to include primary contact (CLI-05)

Purpose: New clients should be created with a primary contact in one atomic operation. This completes CLI-05.
Output: Updated hook and form that create client + primary contact together
</objective>

<execution_context>
@/Users/ayazmohammed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ayazmohammed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-client-contact-system/02-02-SUMMARY.md

# Files to modify
@src/hooks/useClients.ts
@src/components/forms/ClientForm.tsx
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add useCreateClientWithContact hook</name>
  <files>src/hooks/useClients.ts</files>
  <action>
Add a new mutation hook to useClients.ts that uses the atomic save:

```typescript
export function useCreateClientWithContact() {
  const queryClient = useQueryClient()
  const { user } = useAuthStore()
  const { currentTenant } = useTenantStore()
  const tenantId = currentTenant?.id

  return useMutation({
    mutationFn: (input: CreateClientWithContactInput) => {
      if (!tenantId) {
        throw new Error('Cannot create client: No tenant selected')
      }
      if (!user?.id) {
        throw new Error('Cannot create client: User not authenticated')
      }
      return clientsApi.createWithContact(tenantId, user.id, input)
    },
    onSuccess: ({ client, contact }) => {
      // Invalidate clients list
      queryClient.invalidateQueries({ queryKey: ['clients', tenantId] })

      // Set client detail with contact already attached
      queryClient.setQueryData(['client', client.id], {
        ...client,
        contacts: [contact],
        primary_contact: contact,
      })

      // Set contacts query for this client
      queryClient.setQueryData(['contacts', client.id], [contact])

      toast({
        title: 'Client created',
        description: `${client.name} created with primary contact ${contact.first_name} ${contact.last_name}`,
      })
    },
    onError: (error: Error) => {
      toast({
        title: 'Failed to create client',
        description: error.message,
        variant: 'destructive',
      })
    },
  })
}
```

Import CreateClientWithContactInput from @/types/database.

Keep the existing createClient mutation for backward compatibility (updating existing clients without changing contact).
  </action>
  <verify>
1. Run `npm run build` - no TypeScript errors
2. Verify useCreateClientWithContact is exported
  </verify>
  <done>useCreateClientWithContact hook available and correctly caches results</done>
</task>

<task type="auto">
  <name>Task 2: Update ClientForm to include primary contact fields</name>
  <files>src/components/forms/ClientForm.tsx</files>
  <action>
Update ClientForm to collect primary contact information:

1. **Update Zod schema** - add primary contact fields:
```typescript
const clientSchema = z.object({
  // Existing client fields
  name: z.string().min(1, 'Client name is required'),
  status: z.enum(['active', 'inactive']),
  industry: z.string().min(1, 'Industry is required'),
  industry_other: z.string().optional(),
  location: z.string().optional(),
  overview: z.string().optional(),
  portal_enabled: z.boolean(),

  // Primary contact fields
  contact_first_name: z.string().min(1, 'First name is required'),
  contact_last_name: z.string().min(1, 'Last name is required'),
  contact_email: z.string().email('Invalid email').optional().or(z.literal('')),
  contact_phone: z.string().optional(),
  contact_role: z.string().optional(),
})
```

2. **Update default values**:
```typescript
defaultValues: {
  // ... existing defaults
  contact_first_name: '',
  contact_last_name: '',
  contact_email: '',
  contact_phone: '',
  contact_role: '',
}
```

3. **Use new hook**:
```typescript
const createClientWithContact = useCreateClientWithContact()
```

4. **Update onSubmit**:
```typescript
const onSubmit = async (data: ClientFormData) => {
  const finalIndustry = data.industry === 'other' && data.industry_other
    ? data.industry_other
    : data.industry

  await createClientWithContact.mutateAsync({
    client: {
      name: data.name,
      company_name: data.name,
      status: data.status,
      industry: finalIndustry as IndustryType,
      location: data.location,
      overview: data.overview,
      portal_enabled: data.portal_enabled,
    },
    contact: {
      first_name: data.contact_first_name,
      last_name: data.contact_last_name,
      email: data.contact_email || undefined,
      phone: data.contact_phone || undefined,
      role: data.contact_role as ContactRole || undefined,
    },
  })

  form.reset()
  onSuccess?.()
}
```

5. **Add Primary Contact section to form UI** after the Client section:
```tsx
{/* Primary Contact Section */}
<div className="space-y-4 pt-4 border-t">
  <h3 className="text-sm font-medium">Primary Contact</h3>

  <div className="grid grid-cols-2 gap-4">
    <FormField
      control={form.control}
      name="contact_first_name"
      render={({ field }) => (
        <FormItem>
          <FormLabel>First Name *</FormLabel>
          <FormControl>
            <Input {...field} placeholder="John" />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />

    <FormField
      control={form.control}
      name="contact_last_name"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Last Name *</FormLabel>
          <FormControl>
            <Input {...field} placeholder="Doe" />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
  </div>

  <div className="grid grid-cols-2 gap-4">
    <FormField
      control={form.control}
      name="contact_email"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Email</FormLabel>
          <FormControl>
            <Input {...field} type="email" placeholder="john@example.com" />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />

    <FormField
      control={form.control}
      name="contact_phone"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Phone</FormLabel>
          <FormControl>
            <Input {...field} placeholder="+1 (555) 123-4567" />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
  </div>

  <FormField
    control={form.control}
    name="contact_role"
    render={({ field }) => (
      <FormItem>
        <FormLabel>Role</FormLabel>
        <Select onValueChange={field.onChange} value={field.value}>
          <FormControl>
            <SelectTrigger>
              <SelectValue placeholder="Select role..." />
            </SelectTrigger>
          </FormControl>
          <SelectContent>
            {CONTACT_ROLE_OPTIONS.map((option) => (
              <SelectItem key={option.value} value={option.value}>
                {option.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <FormMessage />
      </FormItem>
    )}
  />
</div>
```

6. Import CONTACT_ROLE_OPTIONS from @/lib/utils and ContactRole from @/types/database

7. Update isSubmitting to use new mutation:
```typescript
const isSubmitting = createClientWithContact.isPending
```
  </action>
  <verify>
1. Run `npm run dev`
2. Navigate to client creation form
3. Verify Primary Contact section appears with all fields
4. Fill out form with client + contact data
5. Submit - verify both client and contact are created
6. Navigate to new client detail - verify contact appears in Contacts tab
7. Run `npm run build` - no TypeScript errors
  </verify>
  <done>ClientForm creates client with primary contact atomically; form shows Primary Contact section</done>
</task>

</tasks>

<verification>
- useCreateClientWithContact hook exists and works
- ClientForm has Primary Contact section
- Creating a client also creates primary contact
- New client detail page shows the contact in Contacts tab
- `npm run build` passes
</verification>

<success_criteria>
- CLI-05 complete: useCreateClient accepts primaryContact data
- Atomic save works: client + contact created together
- Form validation requires contact first/last name
- Cache properly updated after creation
</success_criteria>

<output>
After completion, create `.planning/phases/02-client-contact-system/02-03-SUMMARY.md`
</output>
