---
phase: 02-client-contact-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/003_create_client_with_contact.sql
  - src/services/api/clients.ts
  - src/types/database.ts
autonomous: true

must_haves:
  truths:
    - "Database function create_client_with_contact exists and is callable via RPC"
    - "API method createWithContact accepts client and contact data"
    - "Atomic save either succeeds completely or fails completely (no partial saves)"
  artifacts:
    - path: "supabase/migrations/003_create_client_with_contact.sql"
      provides: "PostgreSQL function for atomic client+contact creation"
      contains: "CREATE OR REPLACE FUNCTION create_client_with_contact"
    - path: "src/services/api/clients.ts"
      provides: "API method for atomic client creation"
      contains: "createWithContact"
    - path: "src/types/database.ts"
      provides: "Type for atomic create input"
      contains: "CreateClientWithContactInput"
  key_links:
    - from: "src/services/api/clients.ts"
      to: "supabase.rpc"
      via: "RPC call to create_client_with_contact"
      pattern: "supabase\\.rpc.*create_client_with_contact"
---

<objective>
Create atomic save infrastructure for client + primary contact creation

Purpose: When creating a new client, the primary contact must be saved atomically (both succeed or both fail). This requires a PostgreSQL function and API layer.
Output: Database function + API method that enables atomic client+contact creation
</objective>

<execution_context>
@/Users/ayazmohammed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ayazmohammed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-client-contact-system/02-RESEARCH.md

# Existing patterns
@src/services/api/clients.ts
@src/types/database.ts
@supabase/migrations/002_comprehensive_update.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PostgreSQL function for atomic client+contact save</name>
  <files>supabase/migrations/003_create_client_with_contact.sql</files>
  <action>
Create a new migration file with a PostgreSQL function that:

1. Accepts parameters:
   - p_tenant_id UUID
   - p_user_id UUID
   - p_client_data JSONB (name, company_name, status, industry, location, overview, portal_enabled)
   - p_contact_data JSONB (first_name, last_name, email, phone, role, relationship)

2. Within a transaction:
   - Insert into clients table
   - Insert into contacts table with client_id from step 1, is_primary = true
   - Return JSONB with both client and contact records

3. Handle errors:
   - Use EXCEPTION block to catch and re-raise with context
   - If either insert fails, entire transaction rolls back

4. Use SECURITY DEFINER to run with elevated permissions (for RLS bypass during atomic operation)

5. Add unique partial index for extra safety:
   ```sql
   CREATE UNIQUE INDEX IF NOT EXISTS idx_contacts_one_primary_per_client
     ON contacts(client_id)
     WHERE is_primary = TRUE AND deleted_at IS NULL;
   ```

Reference research: Architecture Pattern 1 in 02-RESEARCH.md has the SQL template.
  </action>
  <verify>
Run the migration in Supabase SQL Editor or via CLI. Verify function exists:
```sql
SELECT proname FROM pg_proc WHERE proname = 'create_client_with_contact';
```
  </verify>
  <done>PostgreSQL function create_client_with_contact exists in database</done>
</task>

<task type="auto">
  <name>Task 2: Add createWithContact method to clients API</name>
  <files>src/services/api/clients.ts, src/types/database.ts</files>
  <action>
1. In src/types/database.ts, add input type:
```typescript
export interface CreateClientWithContactInput {
  client: {
    name: string
    company_name?: string
    status?: ClientStatus
    industry?: IndustryType
    location?: string
    overview?: string
    portal_enabled?: boolean
  }
  contact: {
    first_name: string
    last_name: string
    email?: string
    phone?: string
    role?: ContactRole
    relationship?: string
  }
}

export interface CreateClientWithContactResult {
  client: Client
  contact: Contact
}
```

2. In src/services/api/clients.ts, add method to clientsApi:
```typescript
createWithContact: async (
  tenantId: string,
  userId: string,
  input: CreateClientWithContactInput
): Promise<CreateClientWithContactResult> => {
  const { data, error } = await supabase.rpc('create_client_with_contact', {
    p_tenant_id: tenantId,
    p_user_id: userId,
    p_client_data: input.client,
    p_contact_data: input.contact,
  })

  if (error) throw error

  // Parse the returned JSONB
  return {
    client: data.client as Client,
    contact: data.contact as Contact,
  }
}
```

3. Ensure types are exported from database.ts
  </action>
  <verify>
1. Run `npm run build` - no TypeScript errors
2. Check that createWithContact is available on clientsApi object
  </verify>
  <done>createWithContact API method available and type-safe</done>
</task>

</tasks>

<verification>
- Migration file exists at supabase/migrations/003_create_client_with_contact.sql
- PostgreSQL function is callable
- clientsApi.createWithContact method exists
- Types are properly defined
- `npm run build` passes
</verification>

<success_criteria>
- Atomic save foundation complete
- Database function handles transaction rollback
- API layer ready for hook integration
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-client-contact-system/02-02-SUMMARY.md`

NOTE: User must run the migration SQL in Supabase SQL Editor after this plan completes.
</output>
